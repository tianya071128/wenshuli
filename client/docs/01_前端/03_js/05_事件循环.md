---
title: 事件循环-evnet loop
date: 2021-10-21 15:00:00
permalink: /js/eventloop
categories: 
  - 前端
  - HTML
tags: 
  - null
---

# 事件循环-evnet loop

JS 是运行在渲染进程的主线程的，并且这个主线程还需要处理 DOM，计算样式，处理布局，以及各种事件和网络请求事件等等，是非常繁忙的。

要处理这么多任务还需要保证页面渲染性能，就需要一个系统来统筹调度这些任务，这个系统就是事件循环系统。

## 消息队列

![img](/img/33.png)

渲染进程会不断的从消息队列中取出任务，执行任务，反复如此。

消息队列**是一种数据结构，存放要执行的任务**。

渲染进程有一个 IO 线程专门用来接收其他进程传的消息，接收到消息后，会将这些消息封装成任务**发送给主线程**，主线程将其推入到消息队列中（消息队列也是主线程上的一个数据队列）。

### 消息队列的任务类型

这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。

消息队列中的任务种类繁多，就主要存在以下两个问题：

### 问题一：如何处理高优先级的任务

针对这种情况，微任务就是用来解决高优先级的问题。

消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列（**执行宏任务中的 JS 脚本时，会创建一个调用栈，以及这个微任务队列等等，详见。。。**），在执行宏任务的过程中，可以将高优先级的任务推入到微任务队列，宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务

### 问题二：单个任务执行时间过长

因为所有的任务都是在单线程上执行的，一次只能执行一个任务，当一个任务执行时间过长的话，就会阻塞其他的任务

![img](/img/34.png)

## 宏任务

消息队列中的任务也就是宏任务，主线程上类似于采用一个 for 循环，不断地从消息队列中取出任务并执行任务。

大致流程如下：

* 先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；
* 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；
* 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；
* 最后统计执行完成的时长等信息。

**宏任务的时间粒度比较大，用户设置的两个宏任务之间可能会被插入多个系统级的宏任务。**

::: warning 关于宏任务执行

当执行宏任务的 js 脚本时，并不是说会连续执行下去，有可能会插入其他系统级的任务需要处理。

```js
function fn() {
	// 访问 DOM 时，(猜测)线程控制权就交给了 DOM 机制了，就可能会穿插其他的任务
    console.log(testDom.scrollTop);
}
buttonDom.addEventListener('click', (e) => {
    fn()
    testDom.scrollTop = testDom.scrollTop + 50;
    fn()
 })
```

上述代码的任务执行过程如图：

![image-20211122170556962](/img/35.png)

:::

## 微任务

